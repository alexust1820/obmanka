НЕ СДЕЛАН. СДЕЛАН ЧАСТИЧНО. ГОТОВ. ФОРМАТНУТ. ПРОШЁЛ ПРАВКИ.
RAID (1-8). Чё-то другое (Серёжа) (41-47). SSH (14-16). Файловая система (17-25). Установка (Марк) (26-29). Docker (9-12). Работа с текстом (30-33) (Катя). Процессы (34-39) (Саня Афанасьев)
ОГЛАВЛЕНИЕ
1. Можно ли с помощью технологии LVM заменить RAID 50?
2. Назначение технологии RAID и ее основные характеристики.
3. Что такое системные сервисы? Основные принципы работы с системными сервисами в разных дистрибутивах Linux.
4. По каким характеристикам можно классифицировать дисковые рейды?
5. Назовите алгоритм создания двух логических томов одинакового размера, занимающих все пространство четырех физических дисков в ОС Linux.
6. Чем отличаются RAID 0 от RAID 1? (тупой вопрос относительно прошлого вопроса)
7. В ОС Linux организован дисковый рейд 50, состоящий из 8 дисков. Системные журналы сигнализируют о выходе из строя одного из дисков. Как получить необходимую информацию для точного определения диска и его дальнейшей замены?
8. Как просмотреть структуру физических дисков и логических томов в ОС Linux?
9. Чем отличается технология виртуальных машин от докеризации приложений?
10. Что такое docker compose? Чем отличается команда docker ps от docker ps -a?
11. Назовите основные особенности синтаксиса языка yaml.
12. Что будет происходить при многократных запусках (напр. 100 раз) следующей команды docker run hello-world? В зависимости от ответа: варианты решения.
13. В образе диска, используемого в докере, отсутствует необходимый функционал. Как называется процесс изменения содержания базового образа, и с помощью чего он реализуется?
14. Что такое туннелирование в компьютерных сетях? Примеры использования.
15. Чем подключения VPN отличаются от подключения по протоколу SSH?
16. Алгоритм организации удаленного подключения к ОС Linux по протоколу SSH по ключу. Какие настройки необходимо активировать на стороне сервера?
17. Файловая система ОС Linux позволяет делать snapshot. Можно ли сделанные снимки файловой системы использовать в качестве бэкапов?
18. Где в ОС Linux располагаются исполняемые файлы и как система реализует возможность запуска файлов только по их названию, а не полному пути?
19. На основания чего ОС Linux определяет типы файлов? Какие системные утилиты позволяют получить полную информацию о файле?
20. Назовите основные пути к исполняемым системным файлам в ОС Linux.
21. Опишите назначение основных директорий, расположенных в корне.
22. Что такое мягкие и жесткие ссылки в файловой системе ОС Linux?
23. Для чего применяется файл /etc/fstab?
24. Назовите файловые системы, используемые в ОС Linux и их основные отличия.
25. Механизмы обеспечения безопасности хранения данных в ОС Linux.
26. Основные принципы планирования разбиения дисков для установки ОС Linux.
27. Назовите параметры ОС, изменяемые при первичной настройке сервера на ОС Windows или Linux.
28. Какие варианты установки предусмотрены в ОС Linux?
29. Принципы планирования объемов системных разделов в ОС Linux при установке системы.
30. Приведите варианты создания текстового файла в ОС Linux.Что такое регулярные выражения? Чем отличается POSIX от других стандартов регулярных выражений?
31. Назовите системные утилиты, входящие в набор core, для обработки текста и их функциональное назначение.
32. Приведите варианты поиска текстового файла, содержащего не уникальную запись XYZ среди других подобных 500 файлов без расширения, если известно, что его размер самый маленький среди таких файлов.
33. Назовите способы создания файлов в ОС Linux.
34. Можно ли автоматизировать автоматическое (Ты вообще как? В порядке?) отключение ОС Linux в заданное время и очистку пользовательских файлов в директории /home/user/Downloads? Приведите несколько способов.
35. Принципы автоматизации процессов в ОС Linux.
36. Что такое конвейерная обработка данных и чем она отличается от последовательной?
37. Основные приемы автоматизации задач в ОС Linux.
38. Его нет.
39. С помощью каких утилит в ОС Linux реализуется просмотр и управление процессами?
40. Что такое уровни выполнения? Что делает команда init 6?
41. Что такое точка монтирования диска, и где она может располагаться в структуре ОС Linux?
42. Что такое системные переменные ОС Linux и как можно их изменить?
43. Что такое переменные пользовательского окружения, как получить к ним доступ для изменения?
44. Что такое система логирования и как получить доступ к просмотру логов в ОС Linux?
45. Что включает в себя управление пользователями в ОС Linux и с помощью каких системных команд?
46. Как получить список всех подключенных к ОС Linux сетевых ресурсов? С помощью какой системной утилиты можно управлять подобными подключениями?
47. Пользователь root не может удалить файл /opt/Archive.zip. С помощью чего можно получить подобный результат?
Практика.
1) Со сложением двух чисел
2) С айпишником, рот я его ебал.

1. Можно ли с помощью технологии LVM заменить RAID 50?
LVM (Logical Volume Manager) и RAID (Redundant Array of Independent Disks) - это две разные технологии, предназначенные для разных целей, и они могут использоваться вместе, но не заменяют друг друга.
LVM предоставляет удобный способ управления логическими томами и томами группы томов в Linux. С его помощью вы можете создавать, изменять размеры и объединять различные тома без перезапуска системы. Он не предоставляет механизмы для обеспечения отказоустойчивости и защиты данных, которые предоставляют RAID-массивы.
RAID 50 - это конфигурация RAID, которая объединяет преимущества RAID 5 (паритет) и RAID 0 (стрипинг). Он предоставляет баланс между производительностью и отказоустойчивостью. RAID 50 обеспечивает защиту данных от отказов дисков и предоставляет высокую производительность благодаря стрипингу данных.
Стрипинг - это техника, используемая в технологии RAID (Redundant Array of Independent Disks) для повышения производительности хранения данных. При стрипинге данные разделяются на небольшие блоки (строки или полосы) и распределяются между несколькими физическими дисками. Это позволяет осуществлять параллельное чтение и запись данных на нескольких дисках одновременно.
2. Назначение технологии RAID и ее основные характеристики.
RAID — это технология, с помощью которой может быть организовано хранение данных на жёстких дисках (инструкция, как хранить и читать ваши файлы на дисках). Она применяется для организации хранилищ данных с функциями автоматического резервного копирования или при настройке системного диска с улучшенной отказоустойчивостью.
В зависимости от выбранной спецификации RAID, могут быть повышены скорость чтения / записи и/или уровень защищенности от потери данных.
Cуществуют следующие уровни спецификации RAID: 1,2,3,4,5,6,0, также существуют комбинации: 01,10,50,05,60,06.
Рэйды разделяются на:
Аппаратные - Аппаратные RAID’ы создают дисковый массив до установки ОС и не зависят от неё. Базируются на основе отдельного устройства – RAID-контроллера. Он поддерживает собственный микропроцессор и кэш-память. 
Достоинства: Нагрузка на микропроцессор минимальна. Он характеризуется высокой скоростью чтения и записи, а также хорошей степенью защиты.
Недостаток: Данный тип является самым затратным в плане реализации. 
Программные- массивы создаются в самой операционной системе за счет применения специальных утилит. Обработка данных осуществляется центральным процессором. 
Достоинства: легко создать, можно использовать почти на каждой ОС.
Недостаток: зависимость от предустановленной системы -> это приводит к сильному снижению быстродействия и безопасности хранения документов.
К преимуществам RAID массивов относят:
Увеличение объема диска. Первоначальное предназначение рассматриваемой технологии – это получение диска большей емкости.
Повышение быстродействия системы. Достигается за счет параллельного подключения в массив нескольких физических дисков.
Надежность хранения документов и отказоустойчивость. Результат достигается за счет выделения на резервирование отдельного оборудования. Если один из дисков будет поврежден, RAID-массив не потеряет данные.
Существенных недостатков у технологии нет. К минусам RAID обычно относят стоимость обеспечения соответствующей системы и сложности ее организации. Также необходимо учитывать, что такие массивы могут применяться не всегда.
Чтобы воспользоваться RAID массивами, необходимо обеспечить их аппаратную и программную поддержку. В BIOS должны быть специальные настройки. Они имеют вид типа «SATA Configuration: RAID». Если соответствующий параметр отсутствует, базовую систему ввода-вывода придется «перепрошивать». При отсутствии поддержки RAID программным методом, необходимо подключать дополнительное оборудование.
Ключевые определения в Raid:
Массив. Представляет собой объединение нескольких физических или виртуальных накопителей в один объемный диск. Полученный элемент поддерживает возможность целостной настройки, форматирования и управления.
Метод зеркалирования. Способ повышения надежности хранения информации за счет создания копий исходного диска на другом носителе, включенном в массив.
Дуплекс. Метод зеркалирования. Он поддерживает вдвое большее количество накопителей для создания копий.
Чередование. Это увеличение производительности диска за счет блочной разбивки данных в процессе их первичной записи.
Четность. Так называется технология, включающая в себя чередование и зеркалирование.
Отличия между конфигурациями RAID на диске заключаются в методах формирования и размещения информации, а также в алгоритмах ее дальнейшего распределения на дисках. Базовыми уровнями выступают два основных вида массива – RAID 1 и 0. Остальные – это их производные. Они включают в себя преимущества той или иной «стандартной» модели.
3. Что такое системные сервисы? Основные принципы работы с системными сервисами в разных дистрибутивах Linux.
linux service( служба linux) - это программа или приложение в Linux, которое выполняется или ожидает запуска в фоновом режиме. Daemon - это фактический термин для обозначения этих длительно выполняющихся фоновых процессов. (DNS-серверы, DHCP, веб-серверы (Apache, Nginx)) Служба фактически состоит из одного или нескольких демонов. Как правило, службы Linux обладают следующими характеристиками:
Нет графического интерфейса. 
Сервисы запускаются вместе с системой. Конечно, в данном случае я имею в виду системные сервисы. Сторонние сервисы, такие как MySQL, могут быть настроены на запуск или без запуска с системой.
При работе в фоновом режиме они ждут сигнала для запуска определенной задачи.
В Systemd есть специальный инструмент для управления службами в Linux - команда systemctl. Эта утилита позволяет делать очень много вещей, начиная от перезапуска службы linux и проверки ее состояния, до анализа эффективности загрузки службы. Запустить можно сервисы системные так: sudo systemctl start <имя_службы> Все службы в запущенном состоянии: systemctl --type=service --state=running
4. По каким характеристикам можно классифицировать дисковые рейды?
Уровень рейда: Дисковые рейды могут быть классифицированы по их уровню.
RAID 0
Преимущества. Ключевым преимуществом RAID 0 является производительность. Чередование данных на нескольких дисках обеспечивает большую пропускную способность.
Недостатки. RAID 0 имеет наихудшую защиту данных среди всех уровней RAID. Поскольку он не имеет контроля четности, при отказе диска данные на нем становятся недоступными до тех пор, пока их не удастся перезаписать с другого диска.
Контроль четности осуществляется путем вычисления дополнительного значения (паритета) на основе информации, хранящейся на других дисках. Четность – это механизм целостности данных, реализованный посредством вычисления информации из блоков данных, записанных в массив.  
RAID 1
Преимущества. Данные дублируются (зеркалируются) на двух дисках, обеспечивая избыточность. Зеркалирование дисков хорошо подходит для операций быстрого чтения. Если первичный диск выходит из строя, вторичный, зеркальный диск берет на себя его функции, тк данные, операционная система и прикладное программное обеспечение реплицируются на нем.
Недостатки. Скорость записи ниже, поскольку данные должны быть записаны на диски дважды. Удвоение объема требуемого дискового пространства.
RAID 10 сочетает зеркалирование и чередование дисков. Обычно данные сначала зеркалируются, а затем чередуются, требуется минимум четыре физических диска.
Преимущества. Производительность благодаря RAID 0. Благодаря использованию RAID 1 данные RAID 10 полностью защищены. 
Недостатки. При потере диска в группе чередования необходимо получить доступ к данным из другой группы чередования, поскольку группы чередования не имеют проверки четности. Требуется минимум четыре диска.
RAID 2 осуществляет чередование данных на битовом уровне, и использует код Хэмминга для обеспечения контроля четности и обнаружения ошибок. Информация о четности записывается вместе с исходными данными. 
Код Хэмминга - это метод обнаружения и исправления ошибок в передаче данных. Он основан на добавлении дополнительных битов к информационным битам для создания "кода проверки четности". Когда информационные биты и их проверочные биты передаются, получатель может использовать эти дополнительные проверочные биты для определения и исправления ошибок в данных.
Преимущества. Защита данных. Четность, обеспечиваемая кодом Хэмминга, обеспечивает избыточность данных и отказоустойчивость.
Недостатки. RAID 2 сложнее, чем другие уровни RAID. Требует установки дополнительного дискового накопителя. Вроде уже не используется
RAID 3 использует диск четности (чётность хранится на отдельном диске). Требуется минимум три физических диска.
Преимущества. RAID 3 обеспечивает высокую пропускную способность, что делает его хорошим выбором для передачи больших объемов данных в массовом порядке.
Недостатки. RAID 3 требует дополнительного диска для контроля четности. Поскольку данные о четности хранятся на отдельном диске, RAID 3 работает плохо, когда поступает много небольших запросов на данные, как, например, в приложении базы данных.
В RAID 4 для защиты данных используется выделенный диск четности и чередование дисков на уровне блоков. 
Преимущества. Чередование позволяет считывать данные с любого диска.
Недостатки. Использование выделенного диска четности может вызвать узкие места в производительности при операциях записи, поскольку все записи должны идти на выделенный диск. Редко используется
RAID 5 использует чередование дисков с контролем четности. Данные распределяются по всем дискам. Информация о четности также распределяется по диагонали между дисками. Обеспечивает баланс между производительностью и доступностью.  Требуется не менее трех дисков.
Преимущества. Обеспечивает хорошую пропускную способность и производительность, равную RAID 0. Поскольку данные четности распределяются по всем дискам в наборе RAID, RAID 5 является одним из самых надежных типов, обеспечивая избыточность данных и надежность. Диски RAID 5 можно заменять в горячем режиме, что исключает простои.
Недостатки. Этот уровень RAID также страдает от более длительного времени восстановления и потенциальной потери данных, если второй диск выходит из строя во время восстановления. 

RAID 50, сочетает чередование и распределенный контроль четности. Требуется минимум шесть дисков. 3 для каждого набора RAID 5
Преимущества. Обеспечивает более высокую производительность записи, чем RAID 5. Его функции защиты данных также на ступень выше, чем у RAID 5, а время восстановления быстрее. В случае отказа диска производительность снижается не так сильно, как в случае RAID 5, поскольку страдает только один из массивов RAID 5.
Недостатки. Требование RAID 50 к шести дискам делает его потенциально более дорогим, чем другие типы RAID. Кроме того, как и RAID 5, он требует более сложного контроллера и синхронизированных дисков.
RAID 6: Чередование дисков с двойной четностью. Требуется не менее четырех дисков.
Преимущества. Двойной контроль четности в защищает от потери данных при отказе второго диска. Процент полезной емкости для хранения данных увеличивается по мере добавления дисков. 
Недостатки. Низкая производительность, чем RAID 5. Целых два диска для четности (дорого).
Уровень защиты данных:
Без защиты данных: RAID 0.
Защита от отказа одного диска: RAID 1, RAID 5, RAID 6, RAID 10.
Защита от отказа нескольких дисков: RAID 6.
Производительность:
Высокая производительность: RAID 0, RAID 10.
Хорошая производительность с защитой от отказа: RAID 5, RAID 6, RAID 10.
Хорошая защита от отказа с некоторой стоимостью производительности: RAID 1, RAID 6.
Стойкость к отказам:
Могут выйти из строя несколько дисков без потери данных: RAID 6, RAID 10.
Может выйти из строя один диск без потери данных: RAID 1, RAID 5.
5. Назовите алгоритм создания двух логических томов одинакового размера, занимающих все пространство четырех физических дисков в ОС Linux.
Сначала создаем физические разделы (PV) четырех дисков.
Пример:
Диски: sda, sdb, sdc, sdd (каждый по 10 гб)
pvcreate /dev/sd{a,b,c,d}
Создаем группу томов из физических разделов.
vgcreate group_name /dev/sda /dev/sdb /dev/sdc /dev/sdd   - group_name - название группы томов
Создаем два логических volume 
lvcreate -n volume1 -L20G group_name - volume1 это название логического тома 
lvcreate -n volume2 -L20G group_name - volume2 это название логического тома 
6. Чем отличаются RAID 0 от RAID 1? (тупой вопрос относительно вопроса 4)
RAID 0 осуществляет разделение данных на части и сохраняет их на различных дисках, что позволяет увеличить скорость доступа к данным. Однако, RAID 0 не обеспечивает никакой защиты от потери данных, и если один из дисков выходит из строя, возможна полная потеря всех данных.
RAID 1 создает точную копию данных на других дисках. Это обеспечивает защиту от потери данных в случае отказа одного из дисков, поскольку данные могут быть восстановлены из зеркала. Однако, защита данных в RAID 1 достигается за счет использования большего количества дисков, что может быть менее эффективным с точки зрения использования дискового пространства по сравнению с RAID 0.
Различия между RAID 0 и RAID 1
Уровень Raid
RAID 0
RAID 1
Производительность
Теоретически, он обеспечивает более высокую скорость чтения и записи.
Он предлагает более медленные скорости записи, но может иметь такую же производительность чтения, как RAID 0.
Отказоустойчивость
Нет
Да
Преимущества
Он обладает высокой производительностью «чтения и записи», полностью использует диск и не требует дополнительных затрат на вычисление четности.
Благодаря зеркальному отображению он обладает отказоустойчивостью, что позволяет легко восстанавливать данные в случае сбоя накопителя. Кроме того, его производительность по-прежнему остается выдающейся, даже несмотря на то, что он медленнее, чем RAID 0.
Недостатки
Без зеркалирования, избыточности и отказоустойчивости очень велика вероятность потери данных, и ваши файлы не в безопасности. Если один диск выйдет из строя, вы потеряете не только данные, но и вся система станет недоступной.
При зеркалировании есть две копии всех файлов; следовательно, емкость хранилища сокращается вдвое. Его восстановление требует отключения дисков RAID.
Основные моменты
Акцент на скорости доступа к данным.
Акцент на восстановлении данных
Применение
Он используется там, где надежность данных не так важна, а важна скорость, например, в видеотрансляциях.
Он используется для хранения жизненно важных данных, таких как архивирование данных.

7. В ОС Linux организован дисковый рейд 50, состоящий из 8 дисков. Системные журналы сигнализируют о выходе из строя одного из дисков. Как получить необходимую информацию для точного определения диска и его дальнейшей замены?
Для определения вышедшего из строя диска и его замены в дисковом рейде 50 в ОС Linux можно воспользоваться следующими шагами:
Проверить состояние дисков в рейде с помощью команды mdadm:
sudo mdadm --detail /dev/md<Номер>
Эта команда покажет статус всех дисков в рейде.
Проверить состояние каждого диска в рейде:
sudo mdadm --examine /dev/sdX
Где sdX - это имя диска, который нужно проверить. Эта команда покажет информацию о состоянии конкретного диска.
8. Как просмотреть структуру физических дисков и логических томов в ОС Linux?
ХУЙ ЗНАЕТ НАДО ЛИ ЕЩЕ ЧТО-ТО этого достаточно
Метод 1. Показать разделы диска в Linux с помощью команды Fdisk
Fdisk - это программа с диалоговым управлением и командной строкой, предназначенная для управления разделами и таблицами разделов на жестких дисках Linux. Чтобы воспользоваться преимуществами этой программы, необходимо быть пользователем root. В противном случае появится ошибка "команда не найдена". Если хотите показать разделы диска в Linux, необходимо выполнить команду Fdisk с параметром "-1" (как указано ниже) от имени пользователя "sudo" или "root".
$ sudo fdisk -1
Метод 2. Отображение разделов диска в Linux с помощью команды Lsblk
Эта команда может отобразить подробную информацию обо всех доступных блочных устройствах. Кроме того, с помощью команды lsblk можно получить информацию, связанную с конкретным блочным устройством и его разделами в Linux. Чтобы получить информацию о дисках и разделах, эта команда считывает файловую систему "sysfs" и "udev db". Затем вывод отображается в виде списка в древовидном формате. Используйте приведенную ниже команду для получения списка разделов и дисков.
$ lsblk or $ sudo lsblk




9. Чем отличается технология виртуальных машин от докеризации приложений?
Виртуальная машина (VM) — это виртуальный компьютер со всеми виртуальными устройствами и виртуальным жёстким диском, на который и устанавливается новая независимая ОС (гостевая ОС) вместе с виртуальными драйверами устройств, управлением памятью и другими компонентами. Т. е. мы получаем абстракцию физического оборудования, позволяющую запускать на одном компьютере множество виртуальных компьютеров. Виртуальное оборудование отображается в свойствах системы, а установленные приложения взаимодействуют с ним как с настоящим. При этом сама виртуальная машина полностью изолирована от реального компьютера, хотя и может иметь доступ к его диску и периферийным устройствам.
Установленная VM может по-разному занимать место на диске компьютера:
1) Фиксированное место на жёстком диске, что позволяет осуществлять более быстрый доступ к виртуальному жёсткому диску и позволяет избежать фрагментации файла;
2) Динамическое выделение памяти. При установке дополнительных приложений память будет динамически выделяться под них, пока не достигнет максимального объема, отведенного ей.
При использовании VM появляются дополнительные расходы на эмуляцию виртуального оборудования и запуск гостевой ОС, поддержка и администрирование необходимого окружения для работы вашего приложения. Также при разворачивании большого количества виртуальных машин на сервере объем занимаемого ими места на жёстком диске будет только расти, т.к. для каждой VM требуется место, как минимум, для гостевой ОС и драйверов для виртуальных устройств.
Docker — это ПО для создания приложений на основе контейнеров. Контейнеры и виртуальные машины решают одну задачу, но делают это по-разному. Контейнеры занимают меньше места, т.к. переиспользуют большее количество общих ресурсов хост-системы чем VM, т.к. в отличие от VM, обеспечивает виртуализацию на уровне ОС, а не аппаратного обеспечения. Такой подход обеспечивает меньший объем занимаемого места на жёстком диске, быстрое развертывание и более простое масштабирование.
Docker-контейнер даёт более эффективный механизм инкапсуляции приложений, обеспечивая необходимые интерфейсы хост-системы. Данная возможность позволяет контейнерам разделить ядро системы, где каждый из контейнеров работает как отдельный процесс основной ОС, у которого есть своё собственное виртуальное адресное пространство, таким образом данные, принадлежащие разным областям памяти, не могут быть изменены.
Итого:

10. Что такое docker compose? Чем отличается команда docker ps от docker ps -a?
Docker Compose — это инструмент, входящий в состав Docker. Он предназначен для решения задач, связанных с развёртыванием проектов.
Изучая основы Docker, вы могли столкнуться с созданием простейших приложений, работающих автономно, не зависящих, например, от внешних источников данных или от неких сервисов. На практике же подобные приложения — редкость. Реальные проекты обычно включают в себя целый набор совместно работающих приложений. Поэтому их нужно запускать вместе, что и делает docker compose (оп, раз), запускать их по одному будет занятием долгим и бессмысленным. С его помощью можно даже билдить несколько образов сразу.
docker ps - отображает все активные контейнеры. Ключ -a отобразит все контейнеры, даже выключенные.
11. Назовите основные особенности синтаксиса языка yaml.
В языке есть несколько базовых концепций, которые позволяют обрабатывать большинство данных.
1) Пары ключ-значение:
Большинство данных в YAML-файле хранятся в виде пары ключ-значение, где ключ — это имя пары, а значение — связанные данные. Как например параметр IP-адреса в примере.
А если под значением есть несколько пар ключ - значение (как в случае с nginxweb1), то это будет называться словарём.

2) В yaml используется система отступов как питоне:
Условно начали писать if => его содержимое пишем уже на следующей строчки с пробелами в начале. Так и здесь. Если описываем сервис, ставим два пробела, пишем его название и тд. Табуляции здесь не приветствуются и за них дают по дыхалке. Поэтому тыкаем пробелы ручками в нотпаде.
Это делает синтаксис вменяемым и читаемым.
3) Есть поддержка комментариев.
4) Отсутствие исполняемых файлов:
YAML не содержит исполняемых файлов. Поэтому можно безопасно обмениваться YAML-файлами с третьей стороной.
Чтобы использовать исполняемые файлы, YAML нужно интегрировать с другими языками, например Perl или Java.
12. Что будет происходить при многократных запусках (напр. 100 раз) следующей команды docker run hello-world? В зависимости от ответа: варианты решения.
Если образа с названием hello-world нет на машине, то сначала докер спуллит его с docker.hub, а затем создаст контейнер. При запуске команды 20 раз, он создаст 20 разных контейнеров на основе скачанного/уже имеющегося образа.
13. В образе диска, используемого в докере, отсутствует необходимый функционал. Как называется процесс изменения содержания базового образа, и с помощью чего он реализуется?
Процесс называется коммит, как у гита. Реализуется следующим образом:
1) Запускаем контейнер на основе уже существующего образа.
2) Производим изменения.
3) Выходим через exit.
4) Производим команду docker commit <название контейнера> <название образа, который изменяем>
Названием образа можно указывать новое, тогда будет по факту сделан новый образ.
Можно ещё изменить исходный Dockerfile, а потом заново прописать docker build. Но это жижа какая-то.
14. Что такое туннелирование в компьютерных сетях? Примеры использования.
Туннелирование - процесс, в ходе которого создаётся логическое соединение между двумя точками в сети посредством инкапсуляции (Процесс, в котором данные одного протокола упаковываются в другой) различных протоколов. Таким образом создаётся один логический сегмент сети, и устройства видят друга друга, будто они в одной сети или буквально за устройством, на котором настроен VPN.
Примеры:
1) Когда есть нужда связать сегменты IPv6-сети, а устройства, что находятся между ними, поддерживают только IPv4. И наоборот.
2) Когда нужно подменить свой IP-адрес. Дефолтное расширение в браузере.
3) Дефолтное связывание двух сетей с помощью VPN.
4) Связывание сегментов в одну сеть с помощью L2VPN.
15. Чем подключения VPN отличаются от подключения по протоколу SSH?
VPN (Virtual Private Network) и SSH (Secure Shell) - это два различных подхода к обеспечению безопасного удаленного доступа к сети или серверу. Вот несколько ключевых различий между ними:
1) Цель использования:
VPN: Обычно используется для создания зашифрованного туннеля между устройством пользователя и целевой сетью. VPN позволяет пользователям работать в общественных сетях, таких как интернет, как если бы они были подключены к частной сети.
SSH: Используется для безопасного удаленного доступа к командной строке на удаленном сервере или для передачи данных через зашифрованное соединение.
2) Уровень работы:
VPN: Работает на уровне сетевого соединения
SSH: Работает на уровне приложения.
3) Протоколы:
VPN: Использует различные протоколы, такие как OpenVPN, IPSec, L2TP/IPSec, PPTP и другие, для создания безопасного туннеля.
SSH: Использует протокол SSH (Воу) для создания зашифрованного соединения, обеспечивающего конфиденциальность и целостность данных.
4) Приложения:
VPN: Часто используется для обеспечения безопасного удаленного доступа к корпоративным сетям, обхода географических ограничений или обеспечения безопасности при использовании общественных Wi-Fi сетей.
SSH: Широко применяется для удаленного управления серверами, передачи файлов и туннелирования других сетевых протоколов.
5) Использование ресурсов:
VPN: Может потреблять больше ресурсов, так как защищает все сетевые соединения устройства.
SSH: Обычно более легковесен, так как обеспечивает безопасное соединение только для командной строки или передачи данных через SSH туннель.
В зависимости от конкретных потребностей и сценариев использования можно выбрать между VPN и SSH для обеспечения нужного уровня безопасности и функциональности.
16. Алгоритм организации удаленного подключения к ОС Linux по протоколу SSH по ключу. Какие настройки необходимо активировать на стороне сервера?
Предварительно включаем службу SSH на обоих машинах.
1) Генерируем ключи. (В линукс - это ssh-keygen)
2) Прокидываем их на удалённый сервер. (ssh-copy-id username@remote_host)
3) На удалённом сервере в файле sshd_config включаем аутентификацию по ключу. (PubkeyAuthentication yes)
4) Подключаемся к удалённому серверу. (ssh username@remote_host)
5) На удалённом сервере в файле sshd_config отключить аутентификацию по паролю. (PasswordAuthentication no)
17. Файловая система ОС Linux позволяет делать snapshot. Можно ли сделанные снимки файловой системы использовать в качестве бэкапов?
Мое мнение - можно, но нужно еще и бекапы периодически делать. Snapshot - защита от дурака. Что то удалил случайно или еще что то, но от сдохшего диска не спасет. Думаю, что ему подойдет такой ответ. Ниже больше объяснения и умных слов.
Да, снимки файловой системы в Linux могут использоваться в качестве бэкапов. Они позволяют сохранить состояние файловой системы на определенный момент времени и восстановить ее в этом состоянии в случае необходимости. Однако, следует учитывать, что снимки файловой системы не являются полноценными бэкапами, так как они не включают в себя данные, которые могут быть хранятся вне файловой системы, такие как базы данных или конфигурационные файлы. Кроме того, снимки файловой системы не могут быть использованы для восстановления системы после сбоя жесткого диска или другой катастрофы. Поэтому, для полноценного бэкапа системы рекомендуется использовать специальное программное обеспечение для создания резервных копий, которое позволяет сохранять данные на внешних носителях или в облаке.
18. Где в ОС Linux располагаются исполняемые файлы и как система реализует возможность запуска файлов только по их названию, а не полному пути?
В ОС Linux исполняемые файлы обычно располагаются в каталоге /usr/bin (директория bin - это просто ссылка на эту папку. Скрин ниже с Centos). Эти каталоги содержат большинство установленных приложений и утилит. Кроме того, система Linux использует переменную окружения PATH, которая содержит список каталогов, в которых система ищет исполняемые файлы. Это позволяет запускать файлы только по их названию, а не полному пути. Когда вы вводите имя команды в терминале, система ищет эту команду в каждом каталоге, указанном в переменной PATH, и запускает первый найденный файл.

19. На основания чего ОС Linux определяет типы файлов? Какие системные утилиты позволяют получить полную информацию о файле?
В ОС Linux типы файлов определяются на основе **магических чисел** (magic numbers). Магические числа представляют собой байтовые или битовые последовательности в начале файла, которые служат для его идентификации. Эти последовательности байтов обычно называются "магическими числами" или "магическими байтами". Когда программа или система читает файл, она проверяет его магические числа, чтобы определить тип файла.
Существует несколько системных утилит, которые позволяют получить полную информацию о файле. Например, утилита `file` позволяет определить тип файла, используя магические числа, а также содержание файла. Команда `ls -l` также может использоваться для получения информации о типе файла, а также его правах доступа, владельце и дате создания.
20. Назовите основные пути к исполняемым системным файлам в ОС Linux.
В ОС Linux, исполняемые системные файлы обычно располагаются в следующих директориях:
1. /bin: содержит основные утилиты командной строки, которые могут использоваться как системными, так и обычными пользователями.
2. /sbin: содержит утилиты командной строки, которые могут использоваться только системными администраторами.
3. /usr/bin: содержит утилиты командной строки, которые не являются необходимыми для базовой системы, но могут быть полезными для пользователей.
4. /usr/sbin: содержит утилиты командной строки, которые не являются необходимыми для базовой системы, но могут быть полезными для системных администраторов.
5. /usr/local/bin: содержит утилиты командной строки, которые не являются частью базовой системы и устанавливаются сторонними приложениями.
21. Опишите назначение основных директорий, расположенных в корне.
/bin: содержит основные утилиты командной строки, которые могут использоваться как системными, так и обычными пользователями.
/boot: содержит файлы, необходимые для загрузки системы, такие как ядро и конфигурационные файлы загрузчика.
/dev: содержит специальные файлы, связанные с устройствами, такие как жесткие диски, USB-накопители и т.д.
/etc: содержит конфигурационные файлы для системы и приложений, такие как файлы настроек сети, пользователей и групп.
/home: содержит домашние директории для каждого пользователя в системе.
/lib: содержит библиотеки, используемые системными утилитами и приложениями.
/media: содержит точки монтирования для съёмных носителей, таких как CD-ROM и USB-накопители.
/mnt: содержит точки монтирования для временных файловых систем, таких как NFS-шары и другие сетевые файловые системы.
/opt: содержит дополнительные приложения, которые не являются частью базовой системы.
/proc: содержит виртуальную файловую систему, которая предоставляет информацию о работающих процессах и системе в целом.
/root: домашняя директория для пользователя root.
/run: содержит временные файлы, созданные во время загрузки системы.
/sbin: содержит системные утилиты, которые могут использоваться только системными администраторами.
/srv: содержит данные для служб, предоставляемых системой.
/sys: содержит виртуальную файловую систему, которая предоставляет информацию о состоянии ядра и устройствах.
/tmp: содержит временные файлы, созданные приложениями и системой.
/usr: содержит файлы, необходимые для работы приложений, такие как библиотеки, заголовочные файлы и документацию.
/var: содержит файлы, которые изменяются во время работы системы, такие как журналы, базы данных и временные файлы.
22. Что такое мягкие и жесткие ссылки в файловой системе ОС Linux?
Мягкая ссылка (soft link) или Символическая ссылка (symbolic link) создает указатель на имя файла, а не на область данных. Таким образом, если удалить файл, то символические ссылки, продолжая оставаться в файловой системе, оказываются не рабочими, "битыми".
Жёсткая ссылка (hard link) создаёт ещё одну запись в файловой системе, ссылающуюся на ту же область данных на диске, что и исходный файл. Так как файл это поименованная область на диске, то про жёсткую ссылку можно сказать, что она просто определяет ещё одно наименование уже обозначенной области. Все такие ссылки, включая исходное имя файла воспринимаются системой как синонимы, и сам файл не удаляется пока у него существует хотя бы одно имя. В случае удаления исходного файла, удаляется всего лишь его имя в файловой таблице, но сам файл будет доступен по другим именам.
23. Для чего применяется файл /etc/fstab?
Файл /etc/fstab в ОС Linux используется для автоматического монтирования файловых систем при загрузке систем. Он содержит информацию о различных файловых системах, которые должны быть смонтированы при загрузке системы, а также о том, как их монтировать.
В файле /etc/fstab указываются параметры монтирования для каждой файловой системы, включая устройство, точку монтирования, тип файловой системы и параметры монтирования. Это позволяет системе автоматически монтировать файловые системы при загрузке, что упрощает работу с файлами и директориями.
24. Назовите файловые системы, используемые в ОС Linux и их основные отличия.
ext2: это одна из первых файловых систем, используемых в Linux. Она поддерживает файлы размером до 2 ТБ и не имеет журнала, что делает ее менее надежной, чем более новые файловые системы.
ext3: это улучшенная версия ext2, которая добавляет журналирование, что повышает надежность и скорость работы.
ext4: это последняя версия ext, которая добавляет поддержку файлов размером до 16 ТБ, улучшенное журналирование и другие улучшения производительности.
XFS: это файловая система, разработанная для обработки больших файлов и высоких нагрузок ввода-вывода. Обеспечивает высокую производительность при работе с большими файлами.
Btrfs: это новая файловая система, которая предоставляет множество функций, таких как снимки, сжатие, копирование на запись и другие.
25. Механизмы обеспечения безопасности хранения данных в ОС Linux.
1. Доступы к файлам и директориям: С помощью управления правами к директориям и файлам можно защитить от несанкционированного доступа. Это утилиты chmod И chown
2. Шифрование: ОС Linux поддерживает различные методы шифрования, такие как LUKS (Linux Unified Key Setup) для шифрования дисков и файловых систем, а также GnuPG для шифрования файлов.
3. Мониторинг файловой системы: ОС Linux предоставляет механизмы мониторинга файловой системы, такие как Tripwire и AIDE, которые позволяют обнаруживать изменения в файлах и директориях.
4. Аудит безопасности: ОС Linux предоставляет механизмы аудита безопасности, которые позволяют отслеживать действия пользователей и обнаруживать попытки несанкционированного доступа.
5. Сетевая безопасность: ОС Linux предоставляет механизмы сетевой безопасности, такие как межсетевые экраны (firewall) и протоколы шифрования, которые позволяют защитить данные при передаче по сети .

26. Основные принципы планирования разбиения дисков для установки ОС Linux.
Для правильной установки системы необходимо разбить диск на несколько разделов:
Раздел /boot. На данном разделе хранятся файлы загрузчика Grub.
Корневой раздел / .На данном разделе хранятся системные файлы.
Раздел SWAP. Раздел подкачки 
Раздел /home. На данном разделе хранятся файлы пользователя
Раздел EFI (Extensible Firmware Interface) - если система uefi.
27. Назовите параметры ОС, изменяемые при первичной настройке сервера на ОС Windows или Linux.
Имя сервера, ip-адрес сервера, DNS-сервер. (другое я не знаю. такой вопрос не найти в инете)
28. Какие варианты установки предусмотрены в ОС Linux?
Установка с физического носителя: ОС Linux может быть установлена с CD, DVD, USB-накопителя или жесткого диска.
Установка с сетевого носителя (тот же netinstall): ОС Linux может быть установлена с помощью HTTP, FTP или NFS.
Чистая установка (та же Live CD): Этот метод установки не записывает данные на текущий носитель хранения ОС.
Двойная загрузка: Этот метод позволяет установить Linux на том же носителе, что и текущая ОС.
29. Принципы планирования объемов системных разделов в ОС Linux при установке системы.
Под раздел /boot нужно выделить примерно от 500 мб - 1 Гб.
Корневой раздел / - под него желательно выделить примерно 50 Гб
Swap – половина ОП или вся.
efi - Размерность – 100 МБ.
/home - рекомендуемый объём - всё остальное место на диске.
30. Приведите варианты создания текстового файла в ОС Linux.Что такое регулярные выражения? Чем отличается POSIX от других стандартов регулярных выражений?
Несколько способов создания текстового файла в ОС Linux:
Используя команду touch в терминале: touch filename.txt. Эта команда создаст пустой файл с именем filename.txt в текущей директории.
Используя команду echo в терминале: echo "text" > filename.txt. Эта команда создаст файл с именем filename.txt и запишет в него текст text.
Используя текстовый редактор, такой как nano, vim. Например, чтобы создать файл filename.txt с помощью nano, нужно ввести команду nano filename.txt в терминале. Это откроет текстовый редактор nano, где вы можете ввести текст и сохранить файл.
Регулярные выражения - это шаблоны, используемые для поиска и замены текста в строках. Они могут использоваться в различных языках программирования и утилитах командной строки. POSIX (Portable Operating System Interface) - это стандарт, определяющий регулярные выражения в Unix-подобных операционных системах. Он включает в себя два стандарта: BRE (Basic Regular Expressions) и ERE (Extended Regular Expressions). BRE - это более ограниченный стандарт, чем ERE, но он поддерживается большинством утилит командной строки. ERE - это более мощный стандарт, который поддерживает более широкий набор операций и метасимволов. Также есть и другие стандарты, такие как LIKE, SIMILAR TO, PCRE, но регулярные выражения POSIX предоставляют более мощные средства поиска по шаблонам, чем операторы LIKE и SIMILAR TO, а одно из отличий регулярных выражений PCRE от стандарта Posix в том, что шаблон надо обрамлять разделителями. Разделителем может быть любой символ не являющийся буквой, цифрой, обратной косой чертой или каким-либо пробельным символом.
31. Назовите системные утилиты, входящие в набор core, для обработки текста и их функциональное назначение.
В ядро операционной системы Linux входит набор базовых утилит, предназначенных для обработки текста и выполнения других основных задач. Вот несколько из них:
1) cat:
Функционал: Выводит содержимое файла на стандартный вывод.
Пример использования: cat filename
2) grep:
Функционал: Поиск по тексту с использованием регулярных выражений.
Пример использования: grep "pattern" filename
3) sed (Stream Editor):
Функционал: Программа для поточного (строкового) редактирования текста.
Пример использования: sed 's/old/new/' filename
4) awk:
Функционал: Мощный язык программирования и утилита для обработки и анализа текстовых данных.
Пример использования: awk '{print $1}' filename
5) cut:
Функционал: Выделение (вырезание) определенных частей строки.
Пример использования: cut -d, -f1 filename
6) sort:
Функционал: Сортировка строк текстового файла.
Пример использования: sort filename
7) uniq:
Функционал: Удаление повторяющихся строк в отсортированном файле.
Пример использования: uniq filename
8) tr (translate):
Функционал: Замена или удаление символов.
Пример использования: tr 'a' 'A' < input.txt
9) head:
Функционал: Выводит начальные строки файла (по умолчанию, первые 10 строк).
Пример использования: head filename
10) tail:
Функционал: Выводит конечные строки файла (по умолчанию, последние 10 строк).
Пример использования: tail filename
11) wc (word count):
Функционал: Подсчет числа строк, слов и символов в файле.
Пример использования: wc filename
32. Приведите варианты поиска текстового файла, содержащего не уникальную запись XYZ среди других подобных 500 файлов без расширения, если известно, что его размер самый маленький среди таких файлов.
‘ls -lS’ - отсортирует файлы по убыванию в размере. Если хотим сделать от самого маленького - ‘ls -lSr’
33. Назовите способы создания файлов в ОС Linux.
1) touch:
Команда touch используется для создания пустых файлов или обновления времени доступа и модификации существующего файла. Пример:
touch filename.txt
2) echo:
Команда echo может быть использована для создания файла с определенным содержимым. Например:
echo "Hello, world!" > filename.txt
3) cat:
Команда cat также может использоваться для создания файла и записи в него данных. Пример:
cat > filename.txt
После выполнения этой команды вы можете ввести текст, который будет записан в файл, и затем нажать Ctrl + D, чтобы завершить ввод.
4) nano (или другой текстовый редактор в терминале):
Используйте текстовые редакторы в терминале, такие как nano, чтобы создать и редактировать файлы. Пример:
nano filename.txt
После редактирования файла в nano, используйте Ctrl + X, чтобы выйти, подтвердите сохранение изменений, если необходимо, и нажмите Enter.
5) cp (копирование):
Команда cp также может использоваться для создания копии файла, что, по сути, создаст новый файл. Пример:
cp existingfile.txt newfile.txt
6) dd:
Команда dd позволяет создавать файлы заданного размера с определенным содержимым. Пример:
dd if=/dev/zero of=newfile.txt bs=1024 count=10
Эта команда создаст файл "newfile.txt" размером 10 килобайт, заполнив его нулями.
34. Можно ли автоматизировать автоматическое отключение ОС Linux в заданное время и очистку пользовательских файлов в директории /home/user/Downloads? Приведите несколько способов.
Нам тут нужен прям конкретный скрипт? Вопрос не конкретный вообще.
Можно несколькими способами:
Использование cron: Создайте скрипт, который будет отключать ОС в заданное время и очищать директорию /home/user/Downloads. Добавьте этот скрипт в cron, чтобы он выполнялся по расписанию. Например, для добавления задачи в cron введите команду crontab -e и добавьте строку вида:
* * * * * /путь_к_скрипту/скрипт.sh - тут указать нужное время для нас. кадый час и тп
Использование systemd: Создайте systemd unit, который будет запускать скрипт для отключения ОС и очистки директории /home/user/Downloads. Настройте unit так, чтобы он запускался по расписанию. Например, создайте файл с расширением .service в /etc/systemd/system/ и добавьте в него следующее содержимое:
[Unit]
Description=Shutdown and clean Downloads directory
[Service]
Type=oneshot
ExecStart=/путь_к_скрипту/скрипт.sh
[Timer]
OnCalendar=*-*-* 00:00:00
Использование утилиты at: Создайте скрипт для отключения ОС и очистки директории /home/user/Downloads. Затем запланируйте выполнение этого скрипта в заданное время с помощью утилиты at. Например, введите команду:
echo "/путь_к_скрипту/скрипт.sh" | at 00:00
35. Принципы автоматизации процессов в ОС Linux.
Принципы автоматизации процессов в ОС Linux включают в себя следующие основные аспекты:
Использование скриптов: Создание скриптов на языках программирования, таких как Bash, Python, Perl и других, для автоматизации выполнения определенных задач. С помощью скриптов можно автоматизировать запуск команд, обработку данных, управление файлами и многие другие операции.
Использование планировщиков задач: В Linux есть различные инструменты для планирования выполнения задач, такие как cron и at. С их помощью можно запланировать выполнение определенных действий в определенное время, либо через определенные промежутки времени.
Использование системы systemd: systemd предоставляет возможности для создания служб, таймеров и других юнитов, которые могут автоматически запускать определенные задачи, управлять процессами и ресурсами.
Использование утилит командной строки: В Linux существует множество утилит командной строки, которые могут быть использованы для автоматизации различных задач, таких как управление файлами, обработка текста, сетевые операции и другие.
Использование конфигурационных файлов: Многие приложения и сервисы в Linux имеют конфигурационные файлы, которые можно настроить для автоматического выполнения определенных действий или изменения параметров.
36. Что такое конвейерная обработка данных и чем она отличается от последовательной?
Конвейерная обработка данных (или конвейерные команды) - это метод обработки данных в операционных системах Unix/Linux, который позволяет передавать вывод одной команды на вход другой, создавая цепочку команд для выполнения последовательных операций над данными. Это позволяет создавать сложные последовательности операций без необходимости. 
Отличие конвейерной обработки данных от последовательной заключается в том, что в конвейерной обработке данные обрабатываются последовательно, но без сохранения промежуточных результатов во временных файлах. Это позволяет сократить использование дискового пространства и улучшить производительность, поскольку данные обрабатываются непосредственно в памяти.
В случае последовательной обработки данных каждая команда обрабатывает данные и сохраняет результат в файл, который затем используется как вход для следующей команды. Это может привести к увеличению времени выполнения и использованию дискового пространства из-за необходимости создания и чтения временных файлов.
37. Основные приемы автоматизации задач в ОС Linux.
Автоматизация задач в операционной системе Linux облегчает жизнь системных администраторов и пользователей, позволяя им выполнять повторяющиеся операции с минимальными усилиями. Вот несколько основных приемов автоматизации задач:
1) Shell-скрипты:
Описание: Написание скриптов на языке командной оболочки (например, Bash) для автоматизации серии команд.
Пример: Создание файла с расширением .sh и написание в нем команд, которые вы хотите автоматизировать. Затем выполнение скрипта через терминал: ./myscript.sh
2) Cron:
Описание: Использование утилиты cron для запуска задач по расписанию.
Пример: Редактирование файла crontab с помощью команды crontab -e и добавление задания, которое будет выполняться автоматически в определенное время.
3) Ansible:
Описание: Инструмент автоматизации конфигурации и управления системами.
Пример: Написание плейбуков на языке YAML для определения состояния системы и их применение к группе хостов с использованием Ansible.
4) Systemd:
Описание: Использование системы инициализации systemd для управления службами и заданиями в фоновом режиме.
Пример: Создание и настройка службы systemd, а затем запуск или остановка ее с использованием соответствующих команд.
5) SSH ключи и автоматизация удаленного доступа:
Описание: Использование SSH ключей и инструментов, таких как sshpass или ssh-agent, для автоматизации удаленных задач.
Пример: Генерация SSH ключей, передача их на удаленные серверы, и выполнение команд без запроса пароля.
6) Утилита awk и sed:
Описание: Использование awk и sed для обработки текстовых данных и автоматизации преобразований.
Пример: Написание однострочных команд для поиска, фильтрации и редактирования текстовых файлов.
38. Его нет.
39. С помощью каких утилит в ОС Linux реализуется просмотр и управление процессами?
В операционной системе Linux для просмотра и управления процессами используются различные утилиты командной строки. Некоторые из основных утилит в этой области:
1) ps:
Функционал: Выводит текущие запущенные процессы в виде списка.
Пример использования: ps aux (вывести подробную информацию обо всех процессах).
2) top:
Функционал: Предоставляет интерактивный мониторинг процессов в реальном времени с обновлением каждую секунду.
Пример использования: top
3) htop:
Функционал: Альтернатива для top с более привлекательным интерфейсом и дополнительными возможностями.
Пример использования: htop
4) kill:
Функционал: Завершает (убивает) процесс по его идентификатору (PID).
Пример использования: kill PID (где PID - идентификатор процесса).
5) killall:
Функционал: Завершает все процессы с указанным именем.
Пример использования: killall process_name (где process_name - имя процесса).
6) pkill:
Функционал: Завершает процессы по их имени или другим свойствам.
Пример использования: pkill process_name (где process_name - имя процесса).
7) pgrep:
Функционал: Поиск процессов по их имени и вывод их идентификаторов (PID).
Пример использования: pgrep process_name (где process_name - имя процесса).
40. Что такое уровни выполнения? Что делает команда init 6?
Существует 6(7) уровней выполнения, эти уровни предназначены для управления тем, какие сервисы должны работать в системе. перейдем к уровням:  
Уровень 0(runlevel 0): Завершает работу системы
Уровень 1(runlevel 1): Система в однопользовательском режиме, используется для настройки системы. 
Уровень 2(runlevel 2): Многопользовательский режим, не работают сетевые службы, демоны
Уровень 3(runlevel 3): Многопользовательский режим без графики, это вроде касается только серверных версий линксуса
Уровень 4(runlevel 4): Не используется, чаще всего оставлен для пользователя или разработчиками дистрибутива для своих нужд.
Уровень 5(runlevel 5): Как третий, но с графикой, все десктопные линуксы на нём(даже консольные) хз почему
Уровень 6(runlevel 6): Перезагрузка системы
(думаю теперь ясно что делает команда init 6(если не ясно, то вам поможет только лоботомия(ладно, это штука останавливает все сервисы и перезагружает комп)))
Чтобы узнать текущий уровень выполнения достаточно ввести команду runlevel в командной строке.

На выводе этой команды две цифры. Первая указывает на предыдущий режим работы, а второй на текущий. На скриншоте вместо первой цифры указана буква N, что значит система изначально запускалась и работает в 5 режиме, о чём говорит вторая цифра 5.
systemd использует новые команды, которые в целом используют "runlevel" как "target".
Чтобы просмотреть доступные "target" и уровни выполнения, ассоциированные с ними введите команду:
ls -l /lib/systemd/system/runlevel*
Команда на изменения уровня выполнения по умолчанию:
ln -sf /lib/systemd/system/runlevel3.target /etc/systemd/system/default.target
Здесь создаётся мягкая (-s) ссылка на дефолтный таргет таким образом, чтобы за дефолтный воспринимался третий уровень выполнения. Ключ -f - это дефолтный force.
41. Что такое точка монтирования диска, и где она может располагаться в структуре ОС Linux?
Точка монтирования это каталог к которой монтируется новая файловая система. Монтирование может произойти к любому каталогу, обычно это /mnt, /media или корневой каталог.
42. Что такое системные переменные ОС Linux и как можно их изменить?

Это переменные определяющиеся для всех пользователей они одни для всех пользователей, загружаются при старте системы. Изменить их можно в файлах /etc/environment, /etc/profile, /etc/profile.d/.

43. Что такое переменные пользовательского окружения, как получить к ним доступ для изменения?

Это переменные определяющиеся для конкретного пользователя, в отличии от системных они загружаются при входе пользователя в систему, и являются для каждого пользователя индивидуальными.  А переменные окружения можно настроить в файле ~/.bashrc или ~/.profile для каждого пользователя
44. Что такое система логирования и как получить доступ к просмотру логов в ОС Linux?

Логирование, оно же журналирование, это сбор информации о работе и ошибках в системе. В Linux все лог-файлы находятся в директории /var/log/ все файл смысла разбирать нет смысла, их слишком. Пройдёмся по парочке чтобы было что ему сказать в дополнение:
/var/log/syslog - записывает такие события как:
Запуск и остановка сервисов и демонов
Сообщения ядра об ошибках и критических ситуациях
Информация об изменениях в системных параметрах
Сообщения о сбоях или ошибочных действиях программ
Информация о сетевых соединениях и трафике
Авторизации и аутентификации пользователей
/var/log/auth.log - удачные и неудачные попытки авторизации в системе
Логфайлов вообще дофига и больше, так что достаточно просто знать что это.

45. Что включает в себя управление пользователями в ОС Linux и с помощью каких системных команд?

Управление пользователями заключаются в:
Удалении/добавлении пользователя - deluser и useradd/adduser соответственно
Создание/изменение пароля - passwd
Изменение пользователей:
1.Добавление в группу пользователя: usermod -(a)G <группы> <имя пользователя> (флаг a чтобы старые группы не стирались) 
2.Блокировка/разблокировка пользователя: usermod -L/B <имя пользователя>
3. Изменение имени пользователя(ТОЛЬКО ИМЕНИ) usermod -l <новое имя> <старое>
46. Как получить список всех подключенных к ОС Linux сетевых ресурсов? С помощью какой системной утилиты можно управлять подобными подключениями?
Для просмотра подключений подходит netstat(более старая) и ss(более новая)
(Неясно что имеет ввиду Опалев под “управлением подобными подключениями”, но вот пара утилит)
ip - самая широко функциональная, позволяет настраивать порты, маршруты, показывает информацию об ip-адресах и туннелях и даже настраивать политики IPsec.
Iptables - ну это для ограничения этих самых подключений хз))))))) 
Полагаю, что тут речь про сетевые папки и тд (Серёж, глянь сюда) (Понял)
Если вопрос действительно о сетевых папках, то есть FTP, SSH и SAMBA, чтобы посмотреть все доступные сетевые ресурсы на конкретном хосте(в самбо), необходимо ввести команду sudo smbclient -L \\ИМЯ-КОМПЬЮТЕРА -N.
А из утилит 
mount - для монтирования сетевых файловых систем.
smbclient - для работы с ресурсами Windows сетей.
sshfs - для монтирования удаленных каталогов через SSH.
nfs - для монтирования удаленных каталогов через NFS (Network File System).
scp/rsync - для копирования файлов между локальной и удаленной машиной.

47. Пользователь root не может удалить файл /opt/Archive.zip. С помощью чего можно получить подобный результат?
На файле скорее всего стоит бит неизменяемости(immutable bit). 
Проверить это можно с помощью команды "lsattr /opt/Archive.zip"
В случае если бит правда стоит то результат вывода будет как на фото снизу (Именно параметр i)

Для создания такого файла надо использовать команду sudo chattr +i <название файла>
Чтобы удалить такой файл необходимо убрать бит неизменяемости командой sudo chattr -i <название файла>.
Практика.
1) Со сложением двух чисел
# Функция для вычисления суммы двух чисел
calculate_sum() {
    local result=$(( $1 + $2 ))
    echo $result
}
# Проверка наличия двух аргументов
if [ "$#" -ne 2 ]; then
    echo "Propishi dva argumenta"
    exit 1
fi
# Вызов функции и передача аргументов
sum=$(calculate_sum "$1" "$2")
# Вывод результата
echo "Сумма $1 и $2 равна $sum"
2) С айпишником, рот я его ебал.
# Проверка наличия аргумента
if [ -z "$1" ]; then
    echo "Vvedi 1 argument"
    exit 1
fi
# Проверяем регуляркой на введение самого IP-адреса.
ip_regex='^([0-9]{1,3}\.){3}[0-9]{1,3}$'
# Проверка соответствия введенного текста регулярному выражению
if [[ "$1" =~ $ip_regex ]]; then
  echo "Введен корректный IP-адрес: $1"
  i=1
  while [[ "$i" -lt 5 ]]; do
       # Приравниваем к элементу свеже созданного массива вывод двух команд. Одна вывод содержимого нашего аргумента, который мы передаём, то есть IP. А вторая берёт от него кусочек. По мере цикла он меняется с 1 до 4.
       ip[$i]=$(echo $1 | cut -d '.' -f "$i")
       # Выполняем проверку октета на условие вменяемости
       if [[ ${ip[$i]} -lt 256 ]];
       then
           # Выводим на экран октет-элемент массива.
           echo "ip$i: ${ip[$i]}" 
       else
           # Получаем по дыхалке.
           echo "Segment ${ip[$i]} ne podxodit"
       fi
       # Прибавляем единицу к счётчику для работы цикла.
       ((i++))
    done
else
  echo "Ошибка: Некорректный IP-адрес"
fi
https://docs.google.com/document/d/1FjS9bgpwagbMIAoT1GOH-HxAZCa6KWIaHEGhu-GABGE/edit 
Скрипт на IP без проверки 
#!/bin/bash
#Отделяем каждый октет до точки
arr=($(echo $1 | tr "." "\n"))
#Вывод всех аргументов
echo ${arr[@]}
#Вывод как по заданию
echo "ipv1 = ${arr[0]}, ipv2 = ${arr[1]}, ipv3 = ${arr[2]}, ipv4 = ${arr[3]}"


